<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dynamic User Guide &mdash; pyCADD 1.6.7 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=9b2bca2a"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Demand User Guide" href="demand.html" />
    <link rel="prev" title="Density User Guide" href="density.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pyCADD
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">README</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">pyCADD</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Module User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="dock.html">Dock User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="dance.html">Dance User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="density.html">Density User Guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Dynamic User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">文件准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="#python-dynamic">Python 包调用 Dynamic 模块</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">蛋白结构准备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">小分子结构准备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amber-leap">Amber 模拟前准备 - LEaP</a></li>
<li class="toctree-l3"><a class="reference internal" href="#md">构建MD工作流并执行模拟</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cli-dynamic-md">CLI 调用 Dynamic 模块进行MD模拟</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">部分参数说明</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">模拟结果分析</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cli">CLI快速分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="#python-analyzer">python 包调用 Analyzer 分析工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rmsd-rmsf">RMSD &amp; RMSF 分析</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">氢键分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="demand.html">Demand User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">pyCADD</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyCADD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Dynamic User Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/dynamic.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dynamic-user-guide">
<h1>Dynamic User Guide<a class="headerlink" href="#dynamic-user-guide" title="Permalink to this heading"></a></h1>
<p>pyCADD.Dynamic 模块是为分子动力学模拟的自动化准备与运行而开发的功能模块，目的是为了让研究者专注在分子动力学模拟结果以及少数关键参数上，而无需关心和学习分子动力学模拟准备与执行的具体代码和流程或管道，以期能够提高学术问题的研究效率。</p>
<p>pyCADD提供了Python包调用和CLI(命令行工具)调用两种方式，其中CLI调用方式更加方便，但是Python包调用方式更加灵活。</p>
<section id="id1">
<h2>文件准备<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h2>
<p>Dynamic模块只需要最少的必要输入和几个关键参数调节即可快速开始模拟过程。</p>
<p>要快速执行蛋白-小分子相互作用的分子动力学模拟，首先，您需要准备好一个开展模拟的蛋白结构文件 <code class="docutils literal notranslate"><span class="pre">protein_file</span></code> ，以及一个需要模拟的小分子文件 <code class="docutils literal notranslate"><span class="pre">molecule_file</span></code>, 2个文件都必须是PDB格式(<code class="docutils literal notranslate"><span class="pre">.pdb</span></code>)。</p>
<ul class="simple">
<li><p>为了顺利执行模拟过程，2个结构的坐标应该是“合理”且“相近的”，即分子和蛋白的坐标应该在同一个空间区域中，且分子位于可能结合的位点上。因此，结构应该来自于分子对接软件的对接结果，或X-ray的衍射结构。</p></li>
<li><p>在研究一个新分子的动力学模拟前，应该先将其分子对接到相应的蛋白位点上，然后使用分子对接软件输出PDB格式结构。例如使用 Schrodinger Maestro 将纯蛋白部分与配体小分子拆分，然后<strong>分别</strong>输出为<code class="docutils literal notranslate"><span class="pre">.pdb</span></code>文件。</p></li>
<li><p>蛋白文件不应该包含任何配体小分子及任何水分子，小分子结构也不应该包含任何水分子。</p></li>
<li><p>如果使用 pyCADD.Dock 模块进行过分子对接，则可在 <code class="docutils literal notranslate"><span class="pre">protein</span></code> 及 <code class="docutils literal notranslate"><span class="pre">ligand</span></code> 目录下找到已经拆分好的蛋白和配体小分子的PDB格式结构文件。</p></li>
</ul>
</section>
<section id="python-dynamic">
<h2>Python 包调用 Dynamic 模块<a class="headerlink" href="#python-dynamic" title="Permalink to this heading"></a></h2>
<p>首先 从模块中导入结构预处理器 <code class="docutils literal notranslate"><span class="pre">Processor</span></code> 及实施分子动力学模拟的模拟器 <code class="docutils literal notranslate"><span class="pre">Simulator</span></code>, 然后创建一个预处理器实例 <code class="docutils literal notranslate"><span class="pre">processor</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 如果AMBER 或 Ambertools安装不正确，导入时将收到额外提示</span>
<span class="kn">from</span> <span class="nn">pyCADD.Dynamic</span> <span class="kn">import</span> <span class="n">Processor</span><span class="p">,</span> <span class="n">Simulator</span>
<span class="n">processor</span> <span class="o">=</span> <span class="n">Processor</span><span class="p">()</span>     <span class="c1"># 实例化的同时，将在当前目录创建所有必要的文件夹</span>
</pre></div>
</div>
<section id="id2">
<h3>蛋白结构准备<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<p>使用processor的protein_prepare()方法 对蛋白结构文件进行自动预处理工作。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">processor</span><span class="o">.</span><span class="n">protein_prepare</span><span class="p">(</span><span class="n">protein_file</span><span class="p">,</span> <span class="n">keep_water</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>这一过程包括以下几个步骤(需要AmberTools)：</p>
<ol class="simple">
<li><p>去除蛋白结构中所有的水分子(需要保留参与模拟的重要水分子时，设定keep_water=True), 并补充标准氨基酸残基缺失的原子(add missing atoms), 得到后缀为<code class="docutils literal notranslate"><span class="pre">_dry.pdb</span></code>的文件。</p></li>
<li><p>去除蛋白结构中的所有“原生”H原子，得到后缀为<code class="docutils literal notranslate"><span class="pre">_noH.pdb</span></code>的文件。</p></li>
<li><p>使用AmberTools为蛋白结构重新生成蛋白力场下的H原子，得到后缀为<code class="docutils literal notranslate"><span class="pre">_leap.pdb</span></code>的文件。</p></li>
</ol>
<p>所有此步骤的过程文件保存在<code class="docutils literal notranslate"><span class="pre">protein</span></code>目录中。</p>
</section>
<section id="id3">
<h3>小分子结构准备<a class="headerlink" href="#id3" title="Permalink to this heading"></a></h3>
<p>使用processor的molecule_prepare()方法 对小分子结构文件进行自动预处理工作。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="c1"># charge指定小分子结构的电荷量 根据实际情况改变 </span>
<span class="c1"># 当charge与实际不符时 Gaussian将报错 默认为0</span>
<span class="c1"># multiplicity指定小分子自旋多重度 默认为1</span>

<span class="n">processor</span><span class="o">.</span><span class="n">molecule_prepare</span><span class="p">(</span><span class="n">molecule_file</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;resp&#39;</span><span class="p">)</span>
<span class="c1"># processor.molecule_prepare(molecule_file, charge=0, multiplicity=1, method=&#39;bcc&#39;)</span>
</pre></div>
</div>
<p>这一过程包括以下几个步骤：</p>
<ol class="simple">
<li><p>高斯结构优化 (需要Gaussian 16, 使用泛函B3LYP、基组def2SVP、色散矫正em=GD3BJ、loose收敛限)</p></li>
<li><p>计算小分子的RESP2电荷 (需要Multiwfn)并生成输出PDB结构<code class="docutils literal notranslate"><span class="pre">_out.pdb</span></code> 关于RESP2(0.5)电荷的更多信息，参阅<a class="reference external" href="http://sobereva.com/531">RESP2(0.5)电荷</a></p></li>
<li><p>antechamber (需要AmberTools) 生成Amber模拟模型参数文件<code class="docutils literal notranslate"><span class="pre">.prepin</span></code></p></li>
<li><p>parmchk2 (需要AmberTools) 生成Amber模拟模型参数文件<code class="docutils literal notranslate"><span class="pre">.frcmod</span></code></p></li>
</ol>
<p>可以通过设定 <code class="docutils literal notranslate"><span class="pre">method='bcc'</span></code> 来使用AM1-bcc方法生成电荷而不是resp, 此时1、2步不再执行，也不需要安装Guassian及Multiwfn。<br />所有此步骤的过程文件保存在<code class="docutils literal notranslate"><span class="pre">molecule</span></code>目录中。</p>
</section>
<section id="amber-leap">
<h3>Amber 模拟前准备 - LEaP<a class="headerlink" href="#amber-leap" title="Permalink to this heading"></a></h3>
<p>在蛋白与小分子都准备就绪后，使用LEaP来完成最终的模拟准备文件生成。
为了方便识别生成文件，选择一个任意名称作为生成文件前缀名 <code class="docutils literal notranslate"><span class="pre">prefix</span></code> ，这通常可以是PDBID或配体小分子名等。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;1FBY&#39;</span>
<span class="n">processor</span><span class="o">.</span><span class="n">leap_prepare</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">box_size</span><span class="o">=</span><span class="mf">12.0</span><span class="p">)</span>
</pre></div>
</div>
<p>这一过程包括以下几个步骤：</p>
<ol class="simple">
<li><p>创建tleap命令的输入文件 <code class="docutils literal notranslate"><span class="pre">_tleap.in</span></code></p></li>
<li><p>调用tleap命令为蛋白结构(pro)、小分子结构()lig以及二者复合物(com)生成必要的拓扑及坐标文件<code class="docutils literal notranslate"><span class="pre">.prmtop</span></code>、<code class="docutils literal notranslate"><span class="pre">.inpcrd</span></code></p></li>
<li><p>将复合物溶于TIP3P水箱中 (box_size=12.0) 得到溶剂化复合物结构文件(<code class="docutils literal notranslate"><span class="pre">_comsolvate.pdb</span></code>)，并同时生成拓扑与坐标文件<code class="docutils literal notranslate"><span class="pre">_comsolvate.prmtop</span></code>、<code class="docutils literal notranslate"><span class="pre">_comsolvate.inpcrd</span></code></p></li>
</ol>
<p>所有此步骤的过程文件保存在<code class="docutils literal notranslate"><span class="pre">leap</span></code>目录中，并具有<code class="docutils literal notranslate"><span class="pre">prefix</span></code>前缀。模拟后处理及分析过程将会再次使用它们。</p>
<p>现在，如果没有产生预料之外的错误，预处理阶段已经完成。</p>
</section>
<section id="md">
<h3>构建MD工作流并执行模拟<a class="headerlink" href="#md" title="Permalink to this heading"></a></h3>
<p>为了开始模拟阶段，首先需要此前的预处理器实例<code class="docutils literal notranslate"><span class="pre">processor</span></code>来完成工作流构造。<br />如果您需要不执行准备阶段直接进行模拟，可以参照下面的python命令构建一个新的Processor实例。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 使用set_comsolvate_file(file_path:str, file_type:str)来设定已存在的水箱复合物结构3个必要文件路径</span>
<span class="c1"># 包括_comsolvate.pdb _comsolvate.prmtop _comsolvate.inpcrd</span>
<span class="n">new_processor</span> <span class="o">=</span> <span class="n">Processor</span><span class="p">()</span>
<span class="n">new_processor</span><span class="o">.</span><span class="n">set_comsolvate_file</span><span class="p">(</span><span class="s1">&#39;leap/*_comsolvate.pdb&#39;</span><span class="p">,</span> <span class="s1">&#39;pdb&#39;</span><span class="p">)</span>
<span class="n">new_processor</span><span class="o">.</span><span class="n">set_comsolvate_file</span><span class="p">(</span><span class="s1">&#39;leap/*_comsolvate.prmtop&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span>
<span class="n">new_processor</span><span class="o">.</span><span class="n">set_comsolvate_file</span><span class="p">(</span><span class="s1">&#39;leap/*_comsolvate.inpcrd&#39;</span><span class="p">,</span> <span class="s1">&#39;crd&#39;</span><span class="p">)</span>
<span class="c1"># processor = new_processor</span>
</pre></div>
</div>
<p>首先在工作流中添加能量最小化步骤。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">processor</span><span class="o">.</span><span class="n">add_minimize_process</span><span class="p">(</span><span class="n">process_name</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>
<span class="c1"># 也可以通过设定参数 restraint为True，并在restraint_mask提供约束原子的amber mask来进行有约束的能量最小化</span>
<span class="c1"># processor.add_minimize_process(process_name=&#39;min&#39;, restraint=True, restraint_mask=f&quot;&#39;:1-101&#39;&quot;)</span>
</pre></div>
</div>
<p>然后，为模拟工作流添加加热步骤。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># tgt_temp: 目标温度</span>
<span class="c1"># total_step: 阶段总步数</span>
<span class="c1"># heat_step: 加热环节步数，到达目标温度后将保持该温度直至total_step</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_heat_process</span><span class="p">(</span><span class="n">tgt_temp</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">heat_step</span><span class="o">=</span><span class="mi">9000</span><span class="p">,</span> <span class="n">total_step</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">process_name</span><span class="o">=</span><span class="s1">&#39;heat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>接下来，为模拟工作流添加平衡步骤。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 您可以根据自主需要，创建任意流程的平衡步骤，并在任何步骤中添加约束</span>
<span class="c1"># 所有步骤将被有序依次串联，并在运行模拟时顺序执行</span>

<span class="c1"># restraintmask = &quot;&#39;!(:WAT,Na+,Cl-,K+,K) &amp; !@H= &amp; !@H&#39;&quot;</span>
<span class="c1"># for rest_wt in [4.0, 3.5, 3.0, 2.5, 2.0, 1.0, 0]:</span>
<span class="c1">#     processor.add_npt_process(total_step=5000, process_name=f&#39;eq_npt_reswt{rest_wt}&#39;, restraint_wt=rest_wt, restraintmask=restraintmask)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_npt_process</span><span class="p">(</span><span class="n">total_step</span><span class="o">=</span><span class="mi">500000</span><span class="p">,</span> <span class="n">process_name</span><span class="o">=</span><span class="s1">&#39;eq_npt&#39;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_nvt_process</span><span class="p">(</span><span class="n">total_step</span><span class="o">=</span><span class="mi">500000</span><span class="p">,</span> <span class="n">process_name</span><span class="o">=</span><span class="s1">&#39;eq_nvt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，为工作流添加生产模拟环节。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># is_production 设定为True将在运行时启用一个进度条，告知您当前模拟运行的百分比情况。</span>
<span class="c1"># step_length: 模拟步长，单位为ps</span>
<span class="c1"># total_step: 模拟总步数 模拟总时长 = step_length * total_step 默认为100ns</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_npt_process</span><span class="p">(</span><span class="n">total_step</span><span class="o">=</span><span class="mi">50000000</span><span class="p">,</span> <span class="n">step_length</span><span class="o">=</span><span class="mf">0.002</span><span class="p">,</span> <span class="n">total_step</span><span class="o">=</span><span class="n">step_num</span><span class="p">,</span> <span class="n">is_production</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">process_name</span><span class="o">=</span><span class="s1">&#39;production&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>所有工作流也可仅先生成输入文件，而后添加至工作流框架中。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">processor</span><span class="o">.</span><span class="n">creat_minimize_input</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;min.in&quot;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">creat_heat_input</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;heat.in&quot;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">creat_npt_input</span><span class="p">(</span><span class="n">total_step</span><span class="o">=</span><span class="mi">500000</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;eq_npt.in&quot;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">creat_nvt_input</span><span class="p">(</span><span class="n">total_step</span><span class="o">=</span><span class="mi">500000</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;eq_nvt.in&quot;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">creat_npt_input</span><span class="p">(</span><span class="n">total_step</span><span class="o">=</span><span class="n">step_num</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;production.in&quot;</span><span class="p">)</span>

<span class="n">processor</span><span class="o">.</span><span class="n">add_process</span><span class="p">(</span><span class="s1">&#39;input_file/min.in&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;minimize&#39;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_process</span><span class="p">(</span><span class="s1">&#39;input_file/heat.in&#39;</span><span class="p">,</span> <span class="s1">&#39;heat&#39;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_process</span><span class="p">(</span><span class="s1">&#39;input_file/eq_npt.in&#39;</span><span class="p">,</span> <span class="s1">&#39;eq_npt&#39;</span><span class="p">,</span> <span class="s1">&#39;npt&#39;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_process</span><span class="p">(</span><span class="s1">&#39;input_file/eq_nvt.in&#39;</span><span class="p">,</span> <span class="s1">&#39;eq_nvt&#39;</span><span class="p">,</span> <span class="s1">&#39;nvt&#39;</span><span class="p">)</span>
<span class="n">processor</span><span class="o">.</span><span class="n">add_process</span><span class="p">(</span><span class="s1">&#39;input_file/production.in&#39;</span><span class="p">,</span> <span class="s1">&#39;production&#39;</span><span class="p">,</span> <span class="s1">&#39;npt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>工作流搭建完成后，传递<code class="docutils literal notranslate"><span class="pre">processor</span></code>用于构建一个<code class="docutils literal notranslate"><span class="pre">Simulator</span></code>实例，设定GPU编号即可开始模拟。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">processor</span><span class="p">)</span>

<span class="c1"># 使用shwo_cuda_device()查看当前GPU信息</span>
<span class="c1"># simulator.show_cuda_device()</span>
<span class="n">simulator</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">(</span><span class="n">with_gpu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="cli-dynamic-md">
<h2>CLI 调用 Dynamic 模块进行MD模拟<a class="headerlink" href="#cli-dynamic-md" title="Permalink to this heading"></a></h2>
<p>使用命令</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pycadd-dynamic<span class="w"> </span>auto<span class="w"> </span>PROTEIN_FILE<span class="w"> </span><span class="o">[</span>MOLECULE_FILE<span class="o">]</span>
</pre></div>
</div>
<p>即可快速完成以上全部过程。未提供小分子化合物结构MOLECULE_FILE时，将为Apo结构进行模拟。</p>
<section id="id4">
<h3>部分参数说明<a class="headerlink" href="#id4" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">/</span> <span class="pre">--prefix</span></code>: 指定生成的leap所需文件的前缀名，默认为当前工作目录的名称。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-g</span> <span class="pre">/</span> <span class="pre">--with-gpu</span></code>: 指定 <code class="docutils literal notranslate"><span class="pre">pmemd.cuda</span></code> 使用的GPU编号，默认为0。当系统中有多个GPU时，可以通过该参数指定使用的GPU编号。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">/</span> <span class="pre">--time</span></code>: 指定完成系统平衡后的生产模拟(production) 总时长，单位为ns，默认为100ns。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-w</span> <span class="pre">/</span> <span class="pre">--keep-water</span></code>: 保留原始蛋白文件中存在的水分子。当蛋白文件中存在需要参与模拟过程的重要水分子时，可以使用该参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-b</span> <span class="pre">/</span> <span class="pre">--box-size</span></code>: 设定模拟系统的TIP3P水箱大小，默认为12埃。</p></li>
</ul>
<p>小分子相关参数(Apo结构中将被忽略)：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">/</span> <span class="pre">--charge</span></code>: 指定小分子的总电荷量，默认为0。当分子为非中性时，需要指定该参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-m</span> <span class="pre">/</span> <span class="pre">--multiplicity</span></code>: 指定小分子的自旋多重度，默认为1。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-s</span> <span class="pre">/</span> <span class="pre">--solvent</span></code>: 指定计算RESP2(0.5)电荷时液相的溶剂分子的种类，默认为水(water)。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-n</span> <span class="pre">/</span> <span class="pre">--parallel</span></code>: 指定计算RESP2电荷时所用的CPU核心数量。默认为最大可用核心数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-bcc</span></code>: 使用AM1-bcc方法计算原子电荷，而不是RESP。此时不需要安装Gaussian及Multiwfn。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-k</span> <span class="pre">/</span> <span class="pre">--keep-cood</span></code>: 保留小分子的输入原始坐标用于模拟，而不使用高斯结构优化产生的坐标。需要维持小分子的姿势或坐标不变时，可以使用该参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-O</span> <span class="pre">/</span> <span class="pre">--overwrire</span></code>: 覆盖已存在的文件。默认将跳过先前已完成的小分子准备等过程，当需要从头重新运行模拟时，可以使用该参数。</p></li>
</ul>
<p>A simple demo:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>md
<span class="nb">cd</span><span class="w"> </span>md
cp<span class="w"> </span>SOMEWHERE/pro.pdb<span class="w"> </span>./
cp<span class="w"> </span>SOMEWHERE/lig.pdb<span class="w"> </span>./
pycadd-dynamic<span class="w"> </span>auto<span class="w"> </span>--charge<span class="w"> </span>-1<span class="w"> </span>--multiplicity<span class="w"> </span><span class="m">1</span><span class="w"> </span>--prefix<span class="w"> </span>myMD<span class="w"> </span>--parallel<span class="w"> </span><span class="m">48</span><span class="w"> </span>--with-gpu<span class="w"> </span><span class="m">0</span><span class="w"> </span>pro.pdb<span class="w"> </span>lig.pdb
</pre></div>
</div>
<p>使用</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pycadd-dynamic<span class="w"> </span>--help
pycadd-dynamic<span class="w"> </span>auto<span class="w"> </span>--help
pycadd-dynamic<span class="w"> </span>prepare<span class="w"> </span>--help
pycadd-dynamic<span class="w"> </span>simulate<span class="w"> </span>--help
</pre></div>
</div>
<p>获取CLI接口的更多帮助信息。</p>
</section>
</section>
<section id="id5">
<h2>模拟结果分析<a class="headerlink" href="#id5" title="Permalink to this heading"></a></h2>
<p>Dynamic 的 <code class="docutils literal notranslate"><span class="pre">Analyzer</span></code> 类提供了一些常规的自动化分析工具，用于分析Amber MD模拟结果并快速导出分析数据用于绘制图表。</p>
<p>模拟结果的分析工具需要当前的python环境可以导入<code class="docutils literal notranslate"><span class="pre">pytraj</span></code>包，请在您 <strong>安装Amber的python环境</strong> 中使用分析工具，或使用命令 <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">install</span> <span class="pre">ambertools=23</span> <span class="pre">-c</span> <span class="pre">conda-forge</span></code> 将Ambertools安装到当前环境中。</p>
<section id="cli">
<h3>CLI快速分析<a class="headerlink" href="#cli" title="Permalink to this heading"></a></h3>
<p>使用 <code class="docutils literal notranslate"><span class="pre">pycadd-dynamic</span> <span class="pre">analysis</span></code> 命令可以快速开展常规的轨迹分析，并将结果保存至 <code class="docutils literal notranslate"><span class="pre">analysis</span></code> 目录中。分析轨迹需要提供必要的拓扑及轨迹文件。</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pycadd-dynamic<span class="w"> </span>analysis<span class="w"> </span>-y<span class="w"> </span>TRAJ_FILE<span class="w"> </span>-ro<span class="w"> </span>OUTPUT_FILE<span class="w"> </span>-sp<span class="w"> </span>SOL_COM_TOP_FILE<span class="w"> </span>-cp<span class="w"> </span>COM_TOP_FILE<span class="w"> </span>-lp<span class="w"> </span>LIG_TOP_FILE<span class="w"> </span>-rp<span class="w"> </span>PRO_TOP_FILE<span class="w"> </span><span class="o">[</span>--no-hbond<span class="o">]</span><span class="w"> </span><span class="o">[</span>--no-rmsd<span class="o">]</span><span class="w"> </span><span class="o">[</span>--no-rmsf<span class="o">]</span><span class="w"> </span><span class="o">[</span>-h/--help<span class="o">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-y</span></code> 指定AMBER模拟的轨迹文件，通常为 <code class="docutils literal notranslate"><span class="pre">.nc</span></code> <code class="docutils literal notranslate"><span class="pre">.mdcrd</span></code> <code class="docutils literal notranslate"><span class="pre">.crd</span></code> 格式</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-ro</span></code> 指定分析结果输出的文本文件(<code class="docutils literal notranslate"><span class="pre">.out</span></code>)，该文件中应该包含模拟过程每一帧的状态信息</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-sp</span></code> 指定溶剂复合物拓扑文件, 如<code class="docutils literal notranslate"><span class="pre">*_comsolvate.prmtop</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-cp</span></code> 指定复合物拓扑文件, 如<code class="docutils literal notranslate"><span class="pre">*_com.prmtop</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-lp</span></code> 指定配体拓扑文件, 如<code class="docutils literal notranslate"><span class="pre">*_lig.prmtop</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-rp</span></code> 指定蛋白拓扑文件, 如<code class="docutils literal notranslate"><span class="pre">*_pro.prmtop</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-h/--help</span></code> 查看帮助信息</p></li>
</ul>
<p>默认工作流(WORKFLOW)将进行以下分析：</p>
<ol class="simple">
<li><p>计算模拟体系中蛋白 <strong>alpha C</strong> 的RMSD</p></li>
<li><p>计算模拟体系中蛋白各<strong>残基的RMSF(基于alpha C)</strong></p></li>
<li><p>统计模拟过程的氢键数量、键长、键角等信息，及模拟过程的氢键存续(Lifetime)</p></li>
</ol>
<p>如果您不想以alpha C计算(请通过python包调用方法定制化您的分析过程)或因其他原因需要跳过分析过程，可以通过以下参数：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--no-hbond</span></code> 不进行氢键分析</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--no-rmsd</span></code> 不进行RMSD分析</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--no-rmsf</span></code> 不进行RMSF分析</p></li>
</ul>
</section>
<section id="python-analyzer">
<h3>python 包调用 Analyzer 分析工具<a class="headerlink" href="#python-analyzer" title="Permalink to this heading"></a></h3>
<p>除了使用CLI中固定的工作流进行快速分析外，也可以从 pyCADD.Dynamic 中导入 <code class="docutils literal notranslate"><span class="pre">Analyzer</span></code> 类并在python中定制化分析过程。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 如果AMBER 或 Ambertools安装不正确，导入时将收到额外提示</span>
<span class="kn">from</span> <span class="nn">pyCADD.Dynamic</span> <span class="kn">import</span> <span class="n">Analyzer</span>
</pre></div>
</div>
<p>同样，分析需要提供必要的输出、拓扑及轨迹文件路径。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">traj_file</span> <span class="o">=</span> <span class="s1">&#39;traj.nc&#39;</span>
<span class="n">output_file</span> <span class="o">=</span> <span class="s1">&#39;md.out&#39;</span>
<span class="n">sol_com_top_file</span> <span class="o">=</span> <span class="s1">&#39;*_comsolvate.prmtop&#39;</span>
<span class="n">com_top_file</span> <span class="o">=</span> <span class="s1">&#39;*_com.prmtop&#39;</span>
<span class="n">lig_top_file</span> <span class="o">=</span> <span class="s1">&#39;*_lig.prmtop&#39;</span>
<span class="n">pro_top_file</span> <span class="o">=</span> <span class="s1">&#39;*_pro.prmtop&#39;</span>
</pre></div>
</div>
<p>然后，创建分析器实例来开展分析工作。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">analyzer</span> <span class="o">=</span> <span class="n">Analyzer</span><span class="p">(</span>
    <span class="n">traj_file_path</span> <span class="o">=</span> <span class="n">traj_file</span><span class="p">,</span>
    <span class="n">mdout_file_path</span> <span class="o">=</span> <span class="n">output_file</span><span class="p">,</span>
    <span class="n">comsolvated_topfile_path</span> <span class="o">=</span> <span class="n">sol_com_top_file</span><span class="p">,</span>
    <span class="n">com_topfile_path</span> <span class="o">=</span> <span class="n">com_top_file</span><span class="p">,</span>
    <span class="n">ligand_topfile_path</span> <span class="o">=</span> <span class="n">lig_top_file</span><span class="p">,</span>
    <span class="n">receptor_topfile_path</span> <span class="o">=</span> <span class="n">pro_top_file</span>
<span class="p">)</span>
</pre></div>
</div>
<section id="rmsd-rmsf">
<h4>RMSD &amp; RMSF 分析<a class="headerlink" href="#rmsd-rmsf" title="Permalink to this heading"></a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 默认以αC计算RMSD与RMSF 也可以通过Amber MASK格式指定其他原子</span>
<span class="c1"># 默认参考帧ref为0帧（即第一帧）</span>
<span class="n">analyzer</span><span class="o">.</span><span class="n">calc_rmsd</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="s1">&#39;@CA&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">analyzer</span><span class="o">.</span><span class="n">calc_rmsf</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="s1">&#39;@CA&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id6">
<h4>氢键分析<a class="headerlink" href="#id6" title="Permalink to this heading"></a></h4>
<p>分析器将检测并追踪模拟全过程中指定条件下的氢键（默认为包括蛋白大分子间及蛋白-配体小分子间的全部氢键），然后统计氢键的数量、键长、键角等信息，及模拟过程的氢键存续(Lifetime)。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span># 默认分析所有可能存在的氢键
analyzer.calc_hbond(
    mask = &#39;:*&#39;,
    distance = 3.0,
    angle = 135.0,
    solvent_donor=None,
    solvent_acceptor=None，
    options=None
)
</pre></div>
</div>
<ul class="simple">
<li><p>mask: 指定搜索氢键的原子组范围，使用Amber MASK格式，如<code class="docutils literal notranslate"><span class="pre">:1-10</span></code>表示分析第1-10号残基原子间的氢键，默认为<code class="docutils literal notranslate"><span class="pre">:*</span></code>表示分析所有可能存在的氢键，但不包括溶剂分子</p></li>
<li><p>distance: 指定氢键分析的键长阈值，默认为3.0Å，仅统计重原子间距离小于 <code class="docutils literal notranslate"><span class="pre">distance</span></code> 的氢键</p></li>
<li><p>angle: 指定氢键分析的键角阈值，默认为135.0°，仅统计 A-H-D 键角小于 <code class="docutils literal notranslate"><span class="pre">angle</span></code> 的氢键</p></li>
<li><p>solvent_donor: 指定溶剂中的供体原子Amber MASK，如’:WAT&#64;N’，默认None</p></li>
<li><p>solvent_acceptor: 指定溶剂中的受体原子Amber MASK, 如’:WAT&#64;O’，默认None。若 <code class="docutils literal notranslate"><span class="pre">solvent_donor</span></code> 与 <code class="docutils literal notranslate"><span class="pre">solvent_acceptor</span></code>不为None时，将搜索溶剂与溶质间的氢键，默认仅搜索溶质间的氢键</p></li>
<li><p>options: 其他将被传递到cpptraj的参数，默认为 <code class="docutils literal notranslate"><span class="pre">avgout</span> <span class="pre">HBOND_RESULTS.dat</span> <span class="pre">printatomnum</span> <span class="pre">nointramol</span></code>，参阅<code class="docutils literal notranslate"><span class="pre">cpptraj</span></code>文档获取更多帮助</p></li>
</ul>
<p>所有分析结果可在当前目录下的<code class="docutils literal notranslate"><span class="pre">analysis/</span></code>中找到并用于进一步统计分析与绘图。</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="density.html" class="btn btn-neutral float-left" title="Density User Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="demand.html" class="btn btn-neutral float-right" title="Demand User Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Yuhang Wu.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>