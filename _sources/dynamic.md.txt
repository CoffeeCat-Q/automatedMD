# Dynamic User Guide

pyCADD.Dynamic 模块是为分子动力学模拟的自动化准备与运行而开发的功能模块，目的是为了让研究者专注在分子动力学模拟结果以及少数关键参数上，而无需关心和学习分子动力学模拟准备与执行的具体代码和流程或管道，以期能够提高学术问题的研究效率。

pyCADD提供了Python包调用和CLI(命令行工具)调用两种方式，其中CLI调用方式更加方便，但是Python包调用方式更加灵活。

## 文件准备
Dynamic模块只需要最少的必要输入和几个关键参数调节即可快速开始模拟过程。

要快速执行蛋白-小分子相互作用的分子动力学模拟，首先，您需要准备好一个开展模拟的蛋白结构文件 `protein_file` ，以及一个需要模拟的小分子文件 `molecule_file`, 2个文件都必须是PDB格式(`.pdb`)。
* 为了顺利执行模拟过程，2个结构的坐标应该是“合理”且“相近的”，即分子和蛋白的坐标应该在同一个空间区域中，且分子位于可能结合的位点上。因此，结构应该来自于分子对接软件的对接结果，或X-ray的衍射结构。
* 在研究一个新分子的动力学模拟前，应该先将其分子对接到相应的蛋白位点上，然后使用分子对接软件输出PDB格式结构。例如使用 Schrodinger Maestro 将纯蛋白部分与配体小分子拆分，然后**分别**输出为`.pdb`文件。
* 蛋白文件不应该包含任何配体小分子及任何水分子，小分子结构也不应该包含任何水分子。
* 如果使用 pyCADD.Dock 模块进行过分子对接，则可在 `protein` 及 `ligand` 目录下找到已经拆分好的蛋白和配体小分子的PDB格式结构文件。


## Python 包调用 Dynamic 模块

首先 从模块中导入结构预处理器 `Processor` 及实施分子动力学模拟的模拟器 `Simulator`, 然后创建一个预处理器实例 `processor`

```python
# 如果AMBER 或 Ambertools安装不正确，导入时将收到额外提示
from pyCADD.Dynamic import Processor, Simulator
processor = Processor()     # 实例化的同时，将在当前目录创建所有必要的文件夹
```
### 蛋白结构准备
使用processor的protein_prepare()方法 对蛋白结构文件进行自动预处理工作。
```python
processor.protein_prepare(protein_file)
```
这一过程包括以下几个步骤(需要AmberTools)：  
1. 去除蛋白结构中所有的水分子, 并补充标准氨基酸残基缺失的原子(add missing atoms), 得到后缀为`_dry.pdb`的文件。
2. 去除蛋白结构中的所有“原生”H原子，得到后缀为`_noH.pdb`的文件。
3. 使用AmberTools为蛋白结构重新生成蛋白力场下的H原子，得到后缀为`_leap.pdb`的文件。

所有此步骤的过程文件保存在`protein`目录中。

### 小分子结构准备

使用processor的molecule_prepare()方法 对小分子结构文件进行自动预处理工作。
```python

# charge指定小分子结构的电荷量 根据实际情况改变 
# 当charge与实际不符时 Gaussian将报错 默认为0
# multiplicity指定小分子自旋多重度 默认为1

processor.molecule_prepare(molecule_file, charge=0, multiplicity=1, method='resp')

```

这一过程包括以下几个步骤：
1. 高斯结构优化 (需要Gaussian 16, 使用泛函B3LYP、基组def2SVP、色散矫正em=GD3BJ、loose收敛限)
2. 计算小分子的RESP2电荷 (需要Multiwfn)并生成输出PDB结构`_out.pdb` 关于RESP2(0.5)电荷的更多信息，参阅[RESP2(0.5)电荷](http://sobereva.com/531)
3. antechamber (需要AmberTools) 生成Amber模拟模型参数文件`.prepin`
4. parmchk2 (需要AmberTools) 生成Amber模拟模型参数文件`.frcmod`

可以通过设定 `method='bcc'` 来使用AM1-bcc方法生成电荷而不是resp。  
所有此步骤的过程文件保存在`molecule`目录中。

### Amber 模拟前准备 - LEaP
在蛋白与小分子都准备就绪后，使用LEaP来完成最终的模拟准备文件生成。
为了方便识别生成文件，选择一个任意名称作为生成文件前缀名 `prefix` ，这通常可以是PDBID或配体小分子名等。
```python
prefix = '1FBY'
processor.leap_prepare(prefix)
```
这一过程包括以下几个步骤：
1. 创建tleap命令的输入文件 `_tleap.in`
2. 调用tleap命令为蛋白结构(pro)、小分子结构()lig以及二者复合物(com)生成必要的拓扑及坐标文件`.prmtop`、`.inpcrd`
3. 将复合物溶于TIP3P水箱中 (size=12.0) 得到水箱复合物结构文件(`_comsolvate.pdb`)，并同时生成拓扑与坐标文件`_comsolvate.prmtop`、`_comsolvate.inpcrd`

所有此步骤的过程文件保存在`leap`目录中。

现在，如果没有产生预料之外的错误，预处理阶段已经完成。

### 构建MD工作流并执行模拟
为了开始模拟阶段，首先需要此前的预处理器实例`processor`来完成工作流构造。    
如果您需要不执行准备阶段直接进行模拟，可以参照下面的python命令构建一个新的Processor实例。  
```python
# 使用set_comsolvate_file(file_path:str, file_type:str)来设定已存在的水箱复合物结构3个必要文件路径
# 包括_comsolvate.pdb _comsolvate.prmtop _comsolvate.inpcrd
# new_processor = Processor()
# new_processor.set_comsolvate_file('leap/*_comsolvate.pdb', 'pdb')
# new_processor.set_comsolvate_file('leap/*_comsolvate.prmtop', 'top')
# new_processor.set_comsolvate_file('leap/*_comsolvate.inpcrd', 'crd')
# processor = new_processor
```

首先在工作流中添加能量最小化步骤。
```python
processor.add_minimize_process(process_name='min')
# 也可以通过设定参数 restraint为True，并在restraint_mask提供约束原子的amber mask来进行有约束的能量最小化
# processor.add_minimize_process(process_name='min', restraint=True, restraint_mask=f"':1-101'")
```

然后，为模拟工作流添加加热步骤。
```python
# tgt_temp: 目标温度
# total_step: 阶段总步数
# heat_step: 加热环节步数，到达目标温度后将保持该温度直至total_step
processor.add_heat_process(tgt_temp=300, heat_step=9000, total_step=10000, process_name='heat')
```

接下来，为模拟工作流添加平衡步骤。
```python
# 您可以根据自主需要，创建任意流程的平衡步骤，并在任何步骤中添加约束
# 所有步骤将被有序依次串联，并在运行模拟时顺序执行

# restraintmask = "'!(:WAT,Na+,Cl-,K+,K) & !@H= & !@H'"
# for rest_wt in [4.0, 3.5, 3.0, 2.5, 2.0, 1.0, 0]:
#     processor.add_npt_process(total_step=5000, process_name=f'eq_npt_reswt{rest_wt}', restraint_wt=rest_wt, restraintmask=restraintmask)
processor.add_npt_process(total_step=500000, process_name='eq_npt')
processor.add_nvt_process(total_step=500000, process_name='eq_nvt')
```

最后，为工作流添加生产模拟环节。
```python
# is_production 设定为True将在运行时启用一个进度条，告知您当前模拟运行的百分比情况。
# step_length: 模拟步长，单位为ps
# total_step: 模拟总步数 模拟总时长 = step_length * total_step 默认为100ns
processor.add_npt_process(total_step=50000000, step_length=0.002, total_step=step_num, is_production=True, process_name='production')
```

所有工作流也可仅先生成输入文件，而后添加至工作流框架中。
```python
processor.creat_minimize_input(file_name="min.in")
processor.creat_heat_input(file_name="heat.in")
processor.creat_npt_input(total_step=500000, file_name="eq_npt.in")
processor.creat_nvt_input(total_step=500000, file_name="eq_nvt.in")
processor.creat_npt_input(total_step=step_num, file_name="production.in")

processor.add_process('input_file/stepA.in', 'min', 'minimize')
processor.add_process('input_file/heat.in', 'heat')
processor.add_process('input_file/eq_npt.in', 'eq_npt', 'npt')
processor.add_process('input_file/eq_nvt.in', 'eq_nvt', 'nvt')
processor.add_process('input_file/production.in', 'production', 'npt')
```

工作流搭建完成后，传递`processor`用于构建个模拟器实例，设定GPU编号即可开始模拟。
```python
simulator = Simulator(processor)

# 使用shwo_cuda_device()查看当前GPU信息
# simulator.show_cuda_device()
simulator.run_simulation(with_gpu=0)
```

## CLI 调用 Dynamic 模块进行MD模拟

使用命令
```bash
pycadd-dynamic auto PROTEIN_FILE [MOLECULE_FILE]
```
即可快速完成以上全部过程。
未提供小分子化合物结构MOLECULE_FILE时，将为Apo结构进行模拟。  

A simple demo:
```bash
mkdir md
cd md
cp SOMEWHERE/pro.pdb ./
cp SOMEWHERE/lig.pdb ./
pycadd-dynamic auto --charge -1 --multiplicity 1 --prefix myMD --parallel 48 --with-gpu 0 pro.pdb lig.pdb
```
使用
```bash
pycadd-dynamic --help
pycadd-dynamic auto --help
pycadd-dynamic prepare --help
pycadd-dynamic simulate --help
```
获取CLI接口的更多信息。

## 模拟结果分析

Dynamic 的 `Analyzer` 类提供了一些常规的自动化分析工具，用于分析Amber MD模拟结果并快速导出分析数据用于绘制图表。

### CLI快速分析
使用 `pycadd-dynamic analysis` 命令可以快速开展常规的轨迹分析，并将结果保存至 `analysis` 目录中。分析轨迹需要提供必要的拓扑及轨迹文件。
```bash
pycadd-dynamic analysis -y TRAJ_FILE -ro OUTPUT_FILE -sp SOL_COM_TOP_FILE -cp COM_TOP_FILE -lp LIG_TOP_FILE -rp PRO_TOP_FILE [--no-hbond] [--no-rmsd] [--no-rmsf] [-h/--help]
```
* `-y` 指定AMBER模拟的轨迹文件，通常为 `.nc` `.mdcrd` `.crd` 格式
* `-ro` 指定分析结果输出的文本文件(`.out`)，该文件中应该包含模拟过程每一帧的状态信息
* `-sp` 指定溶剂复合物拓扑文件, 如`*_comsolvate.prmtop`
* `-cp` 指定复合物拓扑文件, 如`*_com.prmtop`
* `-lp` 指定配体拓扑文件, 如`*_lig.prmtop`
* `-rp` 指定蛋白拓扑文件, 如`*_pro.prmtop`
* `-h/--help` 查看帮助信息

默认工作流(WORKFLOW)将进行以下分析：
1. 计算模拟体系中蛋白 **alpha C** 的RMSD
2. 计算模拟体系中蛋白各**残基的RMSF(基于alpha C)**
3. 统计模拟过程的氢键数量、键长、键角等信息，及模拟过程的氢键存续(Lifetime)

如果默认可以通过以下参数来跳过分析过程：
* `--no-hbond` 不进行氢键分析
* `--no-rmsd` 不进行RMSD分析
* `--no-rmsf` 不进行RMSF分析

### python 包调用 Analyzer 分析工具
除了使用CLI中固定的工作流进行快速分析外，也可以从 pyCADD.Dynamic 中导入 `Analyzer` 类并在python中定制化分析过程。
```python
# 如果AMBER 或 Ambertools安装不正确，导入时将收到额外提示
from pyCADD.Dynamic import Analyzer
```

同样，分析需要提供必要的输出、拓扑及轨迹文件路径。
```python
traj_file = 'traj.nc'
output_file = 'md.out'
sol_com_top_file = '*_comsolvate.prmtop'
com_top_file = '*_com.prmtop'
lig_top_file = '*_lig.prmtop'
pro_top_file = '*_pro.prmtop'
```

然后，创建分析器实例来开展分析工作。
```python
analyzer = Analyzer(
    traj_file_path = traj_file,
    mdout_file_path = output_file,
    comsolvated_topfile_path = sol_com_top_file,
    com_topfile_path = com_top_file,
    ligand_topfile_path = lig_top_file,
    receptor_topfile_path = pro_top_file
)
```

#### RMSD & RMSF 分析
```python
# 默认以αC计算RMSD与RMSF 也可以通过Amber MASK格式指定其他原子
# 默认参考帧ref为0帧（即第一帧）
analyzer.calc_rmsd(mask='@CA', ref=0)
analyzer.calc_rmsf(mask='@CA', ref=0)
```

#### 氢键分析
分析器将检测并追踪模拟全过程中指定条件下的氢键（默认为包括蛋白大分子间及蛋白-配体小分子间的全部氢键），然后统计氢键的数量、键长、键角等信息，及模拟过程的氢键存续(Lifetime)。
```python
# 默认分析所有可能存在的氢键
analyzer.calc_hbond(
    mask = ':*',
    distance = 3.0,
    angle = 135.0,
    solvent_donor=None,
    solvent_acceptor=None，
    options=None
)
```
* mask: 指定搜索氢键的原子组范围，使用Amber MASK格式，如`:1-10`表示分析第1-10号残基原子间的氢键，默认为`:*`表示分析所有可能存在的氢键，但不包括溶剂分子
* distance: 指定氢键分析的键长阈值，默认为3.0Å，仅统计重原子间距离小于 `distance` 的氢键
* angle: 指定氢键分析的键角阈值，默认为135.0°，仅统计 A-H-D 键角小于 `angle` 的氢键
* solvent_donor: 指定溶剂中的供体原子Amber MASK，如':WAT@N'，默认None
* solvent_acceptor: 指定溶剂中的受体原子Amber MASK, 如':WAT@O'，默认None。若 `solvent_donor` 与 `solvent_acceptor`不为None时，将搜索溶剂与溶质间的氢键，默认仅搜索溶质间的氢键
* options: 其他将被传递到cpptraj的参数，默认为 `avgout HBOND_RESULTS.dat printatomnum nointramol`，参阅`cpptraj`文档获取更多帮助

所有分析结果可在当前目录下的`analysis`中找到并用于进一步统计分析与绘图。